{"ast":null,"code":"/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport { now, nextTick } from '../../shared/utils.js';\nexport default function Mousewheel(_ref) {\n  let {\n    swiper,\n    extendParams,\n    on,\n    emit\n  } = _ref;\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n\n    // Legacy\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    }\n\n    // side scrolling on FF with DOMMouseScroll\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    }\n\n    // Fall-back if spin cannot be determined\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    }\n\n    // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    }\n    // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    }\n    // If you got here is because an animation has been triggered so store the current time\n    lastScrollTime = new window.Date().getTime();\n    // Return false as a default\n    return false;\n  }\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n    return false;\n  }\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n    const params = swiper.params.mousewheel;\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta;\n\n    // Get the scroll positions\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\n\n    // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      };\n\n      // Keep the most recent events\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent);\n\n      // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      }\n\n      // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n        if (swiper.params.loop) {\n          swiper.loopFix({\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\n            byMousewheel: true\n          });\n        }\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        }\n\n        // Emit event\n        if (!ignoreWheelEvents) emit('scroll', e);\n\n        // Stop autoplay\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\n        // Return page scroll on edge positions\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n  function events(method) {\n    let targetEl = swiper.el;\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\n    }\n    targetEl[method]('mouseenter', handleMouseEnter);\n    targetEl[method]('mouseleave', handleMouseLeave);\n    targetEl[method]('wheel', handle);\n  }\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n    if (swiper.mousewheel.enabled) return false;\n    events('addEventListener');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n    if (!swiper.mousewheel.enabled) return false;\n    events('removeEventListener');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}","map":{"version":3,"names":["getWindow","now","nextTick","Mousewheel","swiper","extendParams","on","emit","window","mousewheel","enabled","releaseOnEdges","invert","forceToAxis","sensitivity","eventsTarget","thresholdDelta","thresholdTime","timeout","lastScrollTime","lastEventBeforeSnap","recentWheelEvents","normalize","e","PIXEL_STEP","LINE_HEIGHT","PAGE_HEIGHT","sX","sY","pX","pY","detail","wheelDelta","wheelDeltaY","wheelDeltaX","axis","HORIZONTAL_AXIS","deltaY","deltaX","shiftKey","deltaMode","spinX","spinY","pixelX","pixelY","handleMouseEnter","mouseEntered","handleMouseLeave","animateSlider","newEvent","params","delta","direction","isEnd","loop","animating","slideNext","raw","isBeginning","slidePrev","Date","getTime","releaseScroll","handle","event","disableParentSwiper","cssMode","preventDefault","targetEl","el","document","querySelector","targetElContainsTarget","contains","target","originalEvent","rtlFactor","rtlTranslate","data","isHorizontal","Math","abs","positions","getTranslate","minTranslate","maxTranslate","nested","stopPropagation","freeMode","time","sign","length","shift","prevEvent","undefined","push","ignoreWheelEvents","position","wasBeginning","wasEnd","setTransition","setTranslate","updateProgress","updateActiveIndex","updateSlidesClasses","loopFix","byMousewheel","sticky","clearTimeout","firstEvent","splice","snapToThreshold","slideToClosest","speed","autoplay","autoplayDisableOnInteraction","stop","returnValue","events","method","enable","wrapperEl","removeEventListener","disable","addEventListener","Object","assign"],"sources":["D:/Inspobox/frontend/node_modules/swiper/modules/mousewheel/mousewheel.js"],"sourcesContent":["/* eslint-disable consistent-return */\r\nimport { getWindow } from 'ssr-window';\r\nimport { now, nextTick } from '../../shared/utils.js';\r\nexport default function Mousewheel({\r\n  swiper,\r\n  extendParams,\r\n  on,\r\n  emit\r\n}) {\r\n  const window = getWindow();\r\n  extendParams({\r\n    mousewheel: {\r\n      enabled: false,\r\n      releaseOnEdges: false,\r\n      invert: false,\r\n      forceToAxis: false,\r\n      sensitivity: 1,\r\n      eventsTarget: 'container',\r\n      thresholdDelta: null,\r\n      thresholdTime: null\r\n    }\r\n  });\r\n  swiper.mousewheel = {\r\n    enabled: false\r\n  };\r\n  let timeout;\r\n  let lastScrollTime = now();\r\n  let lastEventBeforeSnap;\r\n  const recentWheelEvents = [];\r\n  function normalize(e) {\r\n    // Reasonable defaults\r\n    const PIXEL_STEP = 10;\r\n    const LINE_HEIGHT = 40;\r\n    const PAGE_HEIGHT = 800;\r\n    let sX = 0;\r\n    let sY = 0; // spinX, spinY\r\n    let pX = 0;\r\n    let pY = 0; // pixelX, pixelY\r\n\r\n    // Legacy\r\n    if ('detail' in e) {\r\n      sY = e.detail;\r\n    }\r\n    if ('wheelDelta' in e) {\r\n      sY = -e.wheelDelta / 120;\r\n    }\r\n    if ('wheelDeltaY' in e) {\r\n      sY = -e.wheelDeltaY / 120;\r\n    }\r\n    if ('wheelDeltaX' in e) {\r\n      sX = -e.wheelDeltaX / 120;\r\n    }\r\n\r\n    // side scrolling on FF with DOMMouseScroll\r\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\r\n      sX = sY;\r\n      sY = 0;\r\n    }\r\n    pX = sX * PIXEL_STEP;\r\n    pY = sY * PIXEL_STEP;\r\n    if ('deltaY' in e) {\r\n      pY = e.deltaY;\r\n    }\r\n    if ('deltaX' in e) {\r\n      pX = e.deltaX;\r\n    }\r\n    if (e.shiftKey && !pX) {\r\n      // if user scrolls with shift he wants horizontal scroll\r\n      pX = pY;\r\n      pY = 0;\r\n    }\r\n    if ((pX || pY) && e.deltaMode) {\r\n      if (e.deltaMode === 1) {\r\n        // delta in LINE units\r\n        pX *= LINE_HEIGHT;\r\n        pY *= LINE_HEIGHT;\r\n      } else {\r\n        // delta in PAGE units\r\n        pX *= PAGE_HEIGHT;\r\n        pY *= PAGE_HEIGHT;\r\n      }\r\n    }\r\n\r\n    // Fall-back if spin cannot be determined\r\n    if (pX && !sX) {\r\n      sX = pX < 1 ? -1 : 1;\r\n    }\r\n    if (pY && !sY) {\r\n      sY = pY < 1 ? -1 : 1;\r\n    }\r\n    return {\r\n      spinX: sX,\r\n      spinY: sY,\r\n      pixelX: pX,\r\n      pixelY: pY\r\n    };\r\n  }\r\n  function handleMouseEnter() {\r\n    if (!swiper.enabled) return;\r\n    swiper.mouseEntered = true;\r\n  }\r\n  function handleMouseLeave() {\r\n    if (!swiper.enabled) return;\r\n    swiper.mouseEntered = false;\r\n  }\r\n  function animateSlider(newEvent) {\r\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\r\n      // Prevent if delta of wheel scroll delta is below configured threshold\r\n      return false;\r\n    }\r\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\r\n      // Prevent if time between scrolls is below configured threshold\r\n      return false;\r\n    }\r\n\r\n    // If the movement is NOT big enough and\r\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\r\n    //   Don't go any further (avoid insignificant scroll movement).\r\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\r\n      // Return false as a default\r\n      return true;\r\n    }\r\n    // If user is scrolling towards the end:\r\n    //   If the slider hasn't hit the latest slide or\r\n    //   if the slider is a loop and\r\n    //   if the slider isn't moving right now:\r\n    //     Go to next slide and\r\n    //     emit a scroll event.\r\n    // Else (the user is scrolling towards the beginning) and\r\n    // if the slider hasn't hit the first slide or\r\n    // if the slider is a loop and\r\n    // if the slider isn't moving right now:\r\n    //   Go to prev slide and\r\n    //   emit a scroll event.\r\n    if (newEvent.direction < 0) {\r\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\r\n        swiper.slideNext();\r\n        emit('scroll', newEvent.raw);\r\n      }\r\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\r\n      swiper.slidePrev();\r\n      emit('scroll', newEvent.raw);\r\n    }\r\n    // If you got here is because an animation has been triggered so store the current time\r\n    lastScrollTime = new window.Date().getTime();\r\n    // Return false as a default\r\n    return false;\r\n  }\r\n  function releaseScroll(newEvent) {\r\n    const params = swiper.params.mousewheel;\r\n    if (newEvent.direction < 0) {\r\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\r\n        // Return true to animate scroll on edges\r\n        return true;\r\n      }\r\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\r\n      // Return true to animate scroll on edges\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  function handle(event) {\r\n    let e = event;\r\n    let disableParentSwiper = true;\r\n    if (!swiper.enabled) return;\r\n    const params = swiper.params.mousewheel;\r\n    if (swiper.params.cssMode) {\r\n      e.preventDefault();\r\n    }\r\n    let targetEl = swiper.el;\r\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\r\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\r\n    }\r\n    const targetElContainsTarget = targetEl && targetEl.contains(e.target);\r\n    if (!swiper.mouseEntered && !targetElContainsTarget && !params.releaseOnEdges) return true;\r\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\r\n    let delta = 0;\r\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\r\n    const data = normalize(e);\r\n    if (params.forceToAxis) {\r\n      if (swiper.isHorizontal()) {\r\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\r\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\r\n    } else {\r\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\r\n    }\r\n    if (delta === 0) return true;\r\n    if (params.invert) delta = -delta;\r\n\r\n    // Get the scroll positions\r\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\r\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\r\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate();\r\n\r\n    // When loop is true:\r\n    //     the disableParentSwiper will be true.\r\n    // When loop is false:\r\n    //     if the scroll positions is not on edge,\r\n    //     then the disableParentSwiper will be true.\r\n    //     if the scroll on edge positions,\r\n    //     then the disableParentSwiper will be false.\r\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\r\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\r\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\r\n      // Register the new event in a variable which stores the relevant data\r\n      const newEvent = {\r\n        time: now(),\r\n        delta: Math.abs(delta),\r\n        direction: Math.sign(delta),\r\n        raw: event\r\n      };\r\n\r\n      // Keep the most recent events\r\n      if (recentWheelEvents.length >= 2) {\r\n        recentWheelEvents.shift(); // only store the last N events\r\n      }\r\n\r\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\r\n      recentWheelEvents.push(newEvent);\r\n\r\n      // If there is at least one previous recorded event:\r\n      //   If direction has changed or\r\n      //   if the scroll is quicker than the previous one:\r\n      //     Animate the slider.\r\n      // Else (this is the first time the wheel is moved):\r\n      //     Animate the slider.\r\n      if (prevEvent) {\r\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\r\n          animateSlider(newEvent);\r\n        }\r\n      } else {\r\n        animateSlider(newEvent);\r\n      }\r\n\r\n      // If it's time to release the scroll:\r\n      //   Return now so you don't hit the preventDefault.\r\n      if (releaseScroll(newEvent)) {\r\n        return true;\r\n      }\r\n    } else {\r\n      // Freemode or scrollContainer:\r\n\r\n      // If we recently snapped after a momentum scroll, then ignore wheel events\r\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\r\n      // or if it's a new scroll (larger delta or inverse sign as last event before\r\n      // an end-of-momentum snap).\r\n      const newEvent = {\r\n        time: now(),\r\n        delta: Math.abs(delta),\r\n        direction: Math.sign(delta)\r\n      };\r\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\r\n      if (!ignoreWheelEvents) {\r\n        lastEventBeforeSnap = undefined;\r\n        let position = swiper.getTranslate() + delta * params.sensitivity;\r\n        const wasBeginning = swiper.isBeginning;\r\n        const wasEnd = swiper.isEnd;\r\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\r\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\r\n        swiper.setTransition(0);\r\n        swiper.setTranslate(position);\r\n        swiper.updateProgress();\r\n        swiper.updateActiveIndex();\r\n        swiper.updateSlidesClasses();\r\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\r\n          swiper.updateSlidesClasses();\r\n        }\r\n        if (swiper.params.loop) {\r\n          swiper.loopFix({\r\n            direction: newEvent.direction < 0 ? 'next' : 'prev',\r\n            byMousewheel: true\r\n          });\r\n        }\r\n        if (swiper.params.freeMode.sticky) {\r\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\r\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\r\n          // 1. do all N events have decreasing or same (absolute value) delta?\r\n          // 2. did all N events arrive in the last M (M=500?) msecs?\r\n          // 3. does the earliest event have an (absolute value) delta that's\r\n          //    at least P (P=1?) larger than the most recent event's delta?\r\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\r\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\r\n          // Snap immediately and ignore remaining wheel events in this scroll.\r\n          // See comment above for \"remaining wheel events in this scroll\" determination.\r\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\r\n          clearTimeout(timeout);\r\n          timeout = undefined;\r\n          if (recentWheelEvents.length >= 15) {\r\n            recentWheelEvents.shift(); // only store the last N events\r\n          }\r\n\r\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\r\n          const firstEvent = recentWheelEvents[0];\r\n          recentWheelEvents.push(newEvent);\r\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\r\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\r\n            recentWheelEvents.splice(0);\r\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\r\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\r\n            // to wait for more events. Snap ASAP on the next tick.\r\n            // Also, because there's some remaining momentum we'll bias the snap in the\r\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\r\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\r\n            // if it's already scrolled more than 20% in the current direction, keep going.\r\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\r\n            lastEventBeforeSnap = newEvent;\r\n            recentWheelEvents.splice(0);\r\n            timeout = nextTick(() => {\r\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\r\n            }, 0); // no delay; move on next tick\r\n          }\r\n\r\n          if (!timeout) {\r\n            // if we get here, then we haven't detected the end of a momentum scroll, so\r\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\r\n            // for 500ms.\r\n            timeout = nextTick(() => {\r\n              const snapToThreshold = 0.5;\r\n              lastEventBeforeSnap = newEvent;\r\n              recentWheelEvents.splice(0);\r\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\r\n            }, 500);\r\n          }\r\n        }\r\n\r\n        // Emit event\r\n        if (!ignoreWheelEvents) emit('scroll', e);\r\n\r\n        // Stop autoplay\r\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();\r\n        // Return page scroll on edge positions\r\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\r\n      }\r\n    }\r\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\r\n    return false;\r\n  }\r\n  function events(method) {\r\n    let targetEl = swiper.el;\r\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\r\n      targetEl = document.querySelector(swiper.params.mousewheel.eventsTarget);\r\n    }\r\n    targetEl[method]('mouseenter', handleMouseEnter);\r\n    targetEl[method]('mouseleave', handleMouseLeave);\r\n    targetEl[method]('wheel', handle);\r\n  }\r\n  function enable() {\r\n    if (swiper.params.cssMode) {\r\n      swiper.wrapperEl.removeEventListener('wheel', handle);\r\n      return true;\r\n    }\r\n    if (swiper.mousewheel.enabled) return false;\r\n    events('addEventListener');\r\n    swiper.mousewheel.enabled = true;\r\n    return true;\r\n  }\r\n  function disable() {\r\n    if (swiper.params.cssMode) {\r\n      swiper.wrapperEl.addEventListener(event, handle);\r\n      return true;\r\n    }\r\n    if (!swiper.mousewheel.enabled) return false;\r\n    events('removeEventListener');\r\n    swiper.mousewheel.enabled = false;\r\n    return true;\r\n  }\r\n  on('init', () => {\r\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\r\n      disable();\r\n    }\r\n    if (swiper.params.mousewheel.enabled) enable();\r\n  });\r\n  on('destroy', () => {\r\n    if (swiper.params.cssMode) {\r\n      enable();\r\n    }\r\n    if (swiper.mousewheel.enabled) disable();\r\n  });\r\n  Object.assign(swiper.mousewheel, {\r\n    enable,\r\n    disable\r\n  });\r\n}"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}